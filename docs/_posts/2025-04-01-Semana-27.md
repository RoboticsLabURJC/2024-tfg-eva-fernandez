---
title: "Semana 27. Parametrizando y generalizando la caminata"
categories:
  - Weblog
tags:
  - Python
  - Ros2 Humble
  - Gazebo Harmonic
  - Parametrización
  - WEBOTS
---

Esta semana era bastante importante, ya que casi todo el peso y dificultad principal de este TFG se abordaría aquí, ya que mis tareas principales eran:
* Ajustar los tiempos en los movimientos para que queden suaves y naturales
* Hacer que NAO andase recto ajustando los rozamientos del mundo
* Solucionar cierta fatiga detectada la semana anterior (explicaremos esto más adelante)
* Caminar recto a distintas velocidades
* Conseguir caminar con velocidad angular para ahcer arcos

También quería matizar algunas cosas, así que me propuse las siguientes tareas secundarias:
* Arreglar por completo el editor para dejarlo zanjado
* Levantar a NAO desde cúbito supino

# TAREAS PRINCIPALES
## Solucionar rozamientos para que NAO ande recto y suavizar la fatiga

Comencé por esta tarea ya que me parecía la más sencilla, ya que llevaba con ella bastante tiempo, por lo que era sólo continuar hasta dar con los parámetros de rozamiento adecuados, tanto en el mundo como en los pies de NAO.

Para hacer esto, simplemente era editar los ficheros sdf del NAO y el mundo y ver qué combinación daba mejores resultados.

Como mientras estaba probando rozamientos tuve muchos casos de fatiga (NAO no responde a las publicaciones en los topics, como si tuviese las articulaciones bloqueadas, ejemplo en este vídeo):

<video width="800" controls>
  <source src="/2024-tfg-eva-fernandez/images/semana-27/ejemplo_fatiga.webm" type="video/webm">
  Your browser does not support the video tag.
</video>


Decidí tirarme de cabeza a solucionar este problema, cosa que conseguí añadiendo una calidad de servicio a mi programa intérprete de movimientos:

```python
qos_profile = QoSProfile(
    reliability=ReliabilityPolicy.RELIABLE,
    history=HistoryPolicy.KEEP_ALL,
    depth=1000
)
```

Cosa que solucionó bastante el tema de la fatiga y me daba muchas ejecuciones antes de que ocurriese de nuevo, por lo que decidí dejarlo así, ya que no era incómodo como antes y de seguro en la aplicación final no llegará a sobrecargarse de esa manera, ya que para probarlo lo ejecuté muchas veces seguidas. Dejo a continuación cómo funcionaba cuando lo arreglé, sin aun solucionar los rozamientos, pero a punto:

<video width="800" controls>
  <source src="/2024-tfg-eva-fernandez/images/semana-27/menor_fatiga.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video>

Como se puede haber, sigue habiendo fatiga, pero con menor frecuencia y menores consecuencias.

Una vez solucionada la fatiga, continué con el arreglo de los rozamientos.

Cuando lo conseguí, me di cuenta qde que la calidad de servicio no había solucionado tanto como yo creía, ya que tenía muchas cosas abiertas, y se seguía fatigando, por lo pensé que la fatiga se debía a eso y yo no tenía control sobre ello. Por lo que decidí seguir investigándo a ver si encontraba algo al respecto.

En cuanto a esto, dejo aquí una prueba de NAO andando recto y el tema de la fatiga:

<video width="800" controls>
  <source src="/2024-tfg-eva-fernandez/images/semana-27/caminar_recto_con_fatiga.webm" type="video/webm">
  Your browser does not support the video tag.
</video>

Tras un rato de investigación, me di cuenta de que el error estaba en que en el código del intérprete de movimeintos ocurría lo siguiente:

```python
if self.file_name.endswith(".csv"):
    for fotograma in self.datos:
        counter = counter + 1
        tiempo_actual = float(fotograma["#WEBOTS_MOTION"])
        fotograma["tiempo_de_duracion"] = tiempo_actual - tiempo_anterior
        tiempo_anterior = tiempo_actual
        
        # FUENTE DEL FALLO:
        for articulacion in fotograma:
            if articulacion != "#WEBOTS_MOTION" and articulacion != "V1.0":
                self.art_publishers[articulacion] = self.create_publisher(Float64, f'/{articulacion}/cmd_pos', qos_profile)

else:
    for fotograma in self.datos:
        counter = counter + 1
        tiempo_actual = fotograma["tiempo"]
        fotograma["tiempo_de_espera"] = tiempo_actual - tiempo_anterior
        tiempo_anterior = tiempo_actual
        
        # FUENTE DEL FALLO:
        for articulacion in fotograma["articulaciones"]:
            nombre = articulacion["articulacion"]
            self.art_publishers[nombre] = self.create_publisher(Float64, f'/{nombre}/cmd_pos', qos_profile)

```

Lo que hacía que, en lugar de crearse un solo publicador por articulación, se crearan vete tu a saber cuantos, pero demasiados, ya que se ejecutaba la creación de TODOS los publicadores por cada fotograma, cosa que sobrecargaba muchñisimo al sistema.
Cosa que arreglé de la siguiente forma, con un sencillo contador, para que sólo se ejecutase una vez el segundo bucle for:

```python
if self.file_name.endswith(".csv"):
    for fotograma in self.datos:
        counter = counter + 1 # SOLUCIÓN AL FALLO
        tiempo_actual = float(fotograma["#WEBOTS_MOTION"])
        fotograma["tiempo_de_duracion"] = tiempo_actual - tiempo_anterior
        tiempo_anterior = tiempo_actual
        
        # SOLUCIÓN AL FALLO
        if counter == 1:
            for articulacion in fotograma:
                if articulacion != "#WEBOTS_MOTION" and articulacion != "V1.0":
                    self.art_publishers[articulacion] = self.create_publisher(Float64, f'/{articulacion}/cmd_pos', qos_profile)

else:
    for fotograma in self.datos:
        counter = counter + 1 # SOLUCIÓN AL FALLO
        tiempo_actual = fotograma["tiempo"]
        fotograma["tiempo_de_espera"] = tiempo_actual - tiempo_anterior
        tiempo_anterior = tiempo_actual
        
        # SOLUCIÓN AL FALLO
        if counter == 1:
            for articulacion in fotograma["articulaciones"]:
                nombre = articulacion["articulacion"]
                self.art_publishers[nombre] = self.create_publisher(Float64, f'/{nombre}/cmd_pos', qos_profile)
```

Y, después de esto, junto a la calidad de servicio que puse, no me volvió a ocurrir la fatiga:

<video width="800" controls>
  <source src="/2024-tfg-eva-fernandez/images/semana-27/arreglada_fatiga.webm" type="video/webm">
  Your browser does not support the video tag.
</video>

Sin embargo, como se puede observar, me dejó de caminar recto, así que de nuevo me puse a arreglarlo.

Tras un buen rato de pruebas, llegué a este resultado, que me pareció bastante decente:

<video width="800" controls>
  <source src="/2024-tfg-eva-fernandez/images/semana-27/mejor_rozamiento.webm" type="video/webm">
  Your browser does not support the video tag.
</video>

Como estaba más o menos estable, decidí ar esto por terminado de momento y centrarme en las siguientes tareas, y, si era necesario, matizarlo un poco más en el futuro.

## Ajustar tiempos para que los movientos queden suaves y naturales

Como se ve en los vídeos anteriores, los movientos ya son bastante suaves, por lo que decidí dejarlo así.

## Probar distintas velocidades para caminar recto
## Caminar en arco

# TAREAS SECUNDARIAS
## Zanjar el editor

Para dejar zanjado el editor, me di cuenta de que al principio, si movías muy rápido el slider, la articulación hacía muchísima fuerza y NAO salía disparado, además de todo el tema del peso de los pies.

Así que, lo que hice fue cambiar lo de la fuerza para que fuera constante, igual que en el NAO, que está a 0.2 aproximadamente, y lo cuadré para que la velocidad de la articulación en el editor fuera más o menos igual. Para ellos, sólo tuve que añadir **maxvelocity=X**  en las lecturas del slider:

```python
p.setJointMotorControl2(model,27, p.POSITION_CONTROL, targetPosition=R_hip_roll_value, maxVelocity=2)
```

Después, puse los pies con un pco más de peso (2.16184 concretamente). Y obtuve lo siguiente:

<video width="800" controls>
  <source src="/2024-tfg-eva-fernandez/images/semana-27/editor_cocherente.webm" type="video/webm">
  Your browser does not support the video tag.
</video>

Cosa que da muchísima más coherencia a la hora de crear movimientos, no es exacto, pero está muchísimo mejor que antes y el NAO "real" replica los movimientos de forma mucho más exacta.

## Levantar a NAO de cúbito supino

Una vez con el editor coherente, pude hacer que NAO se levantase desde cúbito supino, simplemente haciendo que se diera la vuelta y después levantándolo de cúbito prono.

<video width="800" controls>
  <source src="/2024-tfg-eva-fernandez/images/semana-27/cubito_supino.webm" type="video/webm">
  Your browser does not support the video tag.
</video>

Cabe destacar que hay veces (como la del vídeo) que hay que insistir un poco con el movimiento de cubito prono, pero al final siempres se levanta.

Con lo que podemos concluir que esta semana terminé las tareas secundarias.